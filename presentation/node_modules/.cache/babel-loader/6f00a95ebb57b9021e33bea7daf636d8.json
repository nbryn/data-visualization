{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\"); // wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\n\n\nfunction addSchemaLevelResolveFunction(schema, fn) {\n  // TODO test that schema is a schema, fn is a function\n  var rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(function (x) {\n    return !!x;\n  });\n  rootTypes.forEach(function (type) {\n    // XXX this should run at most once per request to simulate a true root resolver\n    // for graphql-js this is an approximation that works with queries but not mutations\n    var rootResolveFn = runAtMostOncePerRequest(fn);\n    var fields = type.getFields();\n    Object.keys(fields).forEach(function (fieldName) {\n      // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n      // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n      if (type === schema.getSubscriptionType()) {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n      } else {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n      }\n    });\n  });\n} // XXX badly named function. this doesn't really wrap, it just chains resolvers...\n\n\nfunction wrapResolver(innerResolver, outerResolver) {\n  return function (obj, args, ctx, info) {\n    return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n      if (innerResolver) {\n        return innerResolver(root, args, ctx, info);\n      }\n\n      return graphql_1.defaultFieldResolver(root, args, ctx, info);\n    });\n  };\n} // XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\n\n\nfunction runAtMostOncePerRequest(fn) {\n  var value;\n  var randomNumber = Math.random();\n  return function (root, args, ctx, info) {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n\n    return value;\n  };\n}\n\nexports.default = addSchemaLevelResolveFunction;","map":null,"metadata":{},"sourceType":"script"}