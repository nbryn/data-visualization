{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar ReplaceFieldWithFragment =\n/** @class */\nfunction () {\n  function ReplaceFieldWithFragment(targetSchema, fragments) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n\n    for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n      var _a = fragments_1[_i],\n          field = _a.field,\n          fragment = _a.fragment;\n      var parsedFragment = parseFragmentToInlineFragment(fragment);\n      var actualTypeName = parsedFragment.typeCondition.name.value;\n      this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};\n\n      if (this.mapping[actualTypeName][field]) {\n        this.mapping[actualTypeName][field].push(parsedFragment);\n      } else {\n        this.mapping[actualTypeName][field] = [parsedFragment];\n      }\n    }\n  }\n\n  ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n    var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return ReplaceFieldWithFragment;\n}();\n\nexports.default = ReplaceFieldWithFragment;\n\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n  var _a;\n\n  var typeInfo = new graphql_1.TypeInfo(targetSchema);\n  return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType) {\n      var parentTypeName_1 = parentType.name;\n      var selections_1 = node.selections;\n\n      if (mapping[parentTypeName_1]) {\n        node.selections.forEach(function (selection) {\n          if (selection.kind === graphql_1.Kind.FIELD) {\n            var name_1 = selection.name.value;\n            var fragments = mapping[parentTypeName_1][name_1];\n\n            if (fragments && fragments.length > 0) {\n              var fragment = concatInlineFragments(parentTypeName_1, fragments);\n              selections_1 = selections_1.concat(fragment);\n            }\n          }\n        });\n      }\n\n      if (selections_1 !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections_1\n        });\n      }\n    }\n  }, _a)));\n}\n\nfunction parseFragmentToInlineFragment(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    var document_1 = graphql_1.parse(definitions);\n\n    for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n      var definition = _a[_i];\n\n      if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  var query = graphql_1.parse(\"{\" + definitions + \"}\").definitions[0];\n\n  for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n    var selection = _c[_b];\n\n    if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nfunction concatInlineFragments(type, fragments) {\n  var fragmentSelections = fragments.reduce(function (selections, fragment) {\n    return selections.concat(fragment.selectionSet.selections);\n  }, []);\n  var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n  return {\n    kind: graphql_1.Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: graphql_1.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: type\n      }\n    },\n    selectionSet: {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection\n    }\n  };\n}\n\nfunction deduplicateSelection(nodes) {\n  var selectionMap = nodes.reduce(function (map, node) {\n    var _a, _b, _c;\n\n    switch (node.kind) {\n      case 'Field':\n        {\n          if (node.alias) {\n            if (map.hasOwnProperty(node.alias.value)) {\n              return map;\n            } else {\n              return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\n            }\n          } else {\n            if (map.hasOwnProperty(node.name.value)) {\n              return map;\n            } else {\n              return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\n            }\n          }\n        }\n\n      case 'FragmentSpread':\n        {\n          if (map.hasOwnProperty(node.name.value)) {\n            return map;\n          } else {\n            return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\n          }\n        }\n\n      case 'InlineFragment':\n        {\n          if (map.__fragment) {\n            var fragment = map.__fragment;\n            return __assign(__assign({}, map), {\n              __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node])\n            });\n          } else {\n            return __assign(__assign({}, map), {\n              __fragment: node\n            });\n          }\n        }\n\n      default:\n        {\n          return map;\n        }\n    }\n  }, {});\n  var selection = Object.keys(selectionMap).reduce(function (selectionList, node) {\n    return selectionList.concat(selectionMap[node]);\n  }, []);\n  return selection;\n}","map":null,"metadata":{},"sourceType":"script"}