{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _1 = require(\".\");\n\nvar graphql_1 = require(\"graphql\");\n\nvar transforms_1 = require(\"../transforms/transforms\");\n\nvar _2 = require(\".\");\n\nvar ConvertEnumValues_1 = require(\"../transforms/ConvertEnumValues\");\n\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n  if (options instanceof graphql_1.GraphQLSchema) {\n    console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n    options = {\n      schema: options,\n      resolvers: legacyInputResolvers,\n      resolverValidationOptions: legacyInputValidationOptions\n    };\n  }\n\n  var schema = options.schema,\n      inputResolvers = options.resolvers,\n      _a = options.resolverValidationOptions,\n      resolverValidationOptions = _a === void 0 ? {} : _a,\n      _b = options.inheritResolversFromInterfaces,\n      inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n  var _c = resolverValidationOptions.allowResolversNotInSchema,\n      allowResolversNotInSchema = _c === void 0 ? false : _c,\n      requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n  var resolvers = inheritResolversFromInterfaces ? _2.extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers; // Used to map the external value of an enum to its internal value, when\n  // that internal value is provided by a resolver.\n\n  var enumValueMap = Object.create(null);\n  Object.keys(resolvers).forEach(function (typeName) {\n    var resolverValue = resolvers[typeName];\n    var resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" + \"must be of type object or function.\");\n    }\n\n    var type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n    }\n\n    Object.keys(resolverValue).forEach(function (fieldName) {\n      if (fieldName.startsWith('__')) {\n        // this is for isTypeOf and resolveType and all the other stuff.\n        type[fieldName.substring(2)] = resolverValue[fieldName];\n        return;\n      }\n\n      if (type instanceof graphql_1.GraphQLScalarType) {\n        type[fieldName] = resolverValue[fieldName];\n        return;\n      }\n\n      if (type instanceof graphql_1.GraphQLEnumType) {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n        } // We've encountered an enum resolver that is being used to provide an\n        // internal enum value.\n        // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n        //\n        // We're storing a map of the current enums external facing value to\n        // its resolver provided internal value. This map is used to transform\n        // the current schema to a new schema that includes enums with the new\n        // internal value.\n\n\n        enumValueMap[type.name] = enumValueMap[type.name] || {};\n        enumValueMap[type.name][fieldName] = resolverValue[fieldName];\n        return;\n      } // object type\n\n\n      var fields = getFieldsForType(type);\n\n      if (!fields) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n      }\n\n      if (!fields[fieldName]) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n      }\n\n      var field = fields[fieldName];\n      var fieldResolve = resolverValue[fieldName];\n\n      if (typeof fieldResolve === 'function') {\n        // for convenience. Allows shorter syntax in resolver definition file\n        setFieldProperties(field, {\n          resolve: fieldResolve\n        });\n      } else {\n        if (typeof fieldResolve !== 'object') {\n          throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n        }\n\n        setFieldProperties(field, fieldResolve);\n      }\n    });\n  });\n\n  _2.checkForResolveTypeResolver(schema, requireResolversForResolveType); // If there are any enum resolver functions (that are used to return\n  // internal enum values), create a new schema that includes enums with the\n  // new internal facing values.\n\n\n  var updatedSchema = transforms_1.applySchemaTransforms(schema, [new ConvertEnumValues_1.default(enumValueMap)]);\n  return updatedSchema;\n}\n\nfunction getFieldsForType(type) {\n  if (type instanceof graphql_1.GraphQLObjectType || type instanceof graphql_1.GraphQLInterfaceType) {\n    return type.getFields();\n  } else {\n    return undefined;\n  }\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  Object.keys(propertiesObj).forEach(function (propertyName) {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n\nexports.default = addResolveFunctionsToSchema;","map":null,"metadata":{},"sourceType":"script"}