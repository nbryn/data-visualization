{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar error_1 = require(\"graphql/error\");\n\nvar getResponseKeyFromInfo_1 = require(\"./getResponseKeyFromInfo\");\n\nif (typeof global !== 'undefined' && 'Symbol' in global || typeof window !== 'undefined' && 'Symbol' in window) {\n  exports.ERROR_SYMBOL = Symbol('subSchemaErrors');\n} else {\n  exports.ERROR_SYMBOL = '@@__subSchemaErrors';\n}\n\nfunction annotateWithChildrenErrors(object, childrenErrors) {\n  var _a;\n\n  if (!childrenErrors || childrenErrors.length === 0) {\n    // Nothing to see here, move along\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    var byIndex_1 = {};\n    childrenErrors.forEach(function (error) {\n      if (!error.path) {\n        return;\n      }\n\n      var index = error.path[1];\n      var current = byIndex_1[index] || [];\n      current.push(__assign(__assign({}, error), {\n        path: error.path.slice(1)\n      }));\n      byIndex_1[index] = current;\n    });\n    return object.map(function (item, index) {\n      return annotateWithChildrenErrors(item, byIndex_1[index]);\n    });\n  }\n\n  return __assign(__assign({}, object), (_a = {}, _a[exports.ERROR_SYMBOL] = childrenErrors.map(function (error) {\n    return __assign(__assign({}, error), error.path ? {\n      path: error.path.slice(1)\n    } : {});\n  }), _a));\n}\n\nexports.annotateWithChildrenErrors = annotateWithChildrenErrors;\n\nfunction getErrorsFromParent(object, fieldName) {\n  var errors = object && object[exports.ERROR_SYMBOL] || [];\n  var childrenErrors = [];\n\n  for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n    var error = errors_1[_i];\n\n    if (!error.path || error.path.length === 1 && error.path[0] === fieldName) {\n      return {\n        kind: 'OWN',\n        error: error\n      };\n    } else if (error.path[0] === fieldName) {\n      childrenErrors.push(error);\n    }\n  }\n\n  return {\n    kind: 'CHILDREN',\n    errors: childrenErrors\n  };\n}\n\nexports.getErrorsFromParent = getErrorsFromParent;\n\nvar CombinedError =\n/** @class */\nfunction (_super) {\n  __extends(CombinedError, _super);\n\n  function CombinedError(message, errors) {\n    var _this = _super.call(this, message) || this;\n\n    _this.errors = errors;\n    return _this;\n  }\n\n  return CombinedError;\n}(Error);\n\nfunction checkResultAndHandleErrors(result, info, responseKey) {\n  if (!responseKey) {\n    responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);\n  }\n\n  if (result.errors && (!result.data || result.data[responseKey] == null)) {\n    // apollo-link-http & http-link-dataloader need the\n    // result property to be passed through for better error handling.\n    // If there is only one error, which contains a result property, pass the error through\n    var newError = result.errors.length === 1 && hasResult(result.errors[0]) ? result.errors[0] : new CombinedError(concatErrors(result.errors), result.errors);\n    throw error_1.locatedError(newError, info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n  }\n\n  var resultObject = result.data[responseKey];\n\n  if (result.errors) {\n    resultObject = annotateWithChildrenErrors(resultObject, result.errors);\n  }\n\n  return resultObject;\n}\n\nexports.checkResultAndHandleErrors = checkResultAndHandleErrors;\n\nfunction concatErrors(errors) {\n  return errors.map(function (error) {\n    return error.message;\n  }).join('\\n');\n}\n\nfunction hasResult(error) {\n  return error.result || error.extensions || error.originalError && error.originalError.result;\n}","map":null,"metadata":{},"sourceType":"script"}